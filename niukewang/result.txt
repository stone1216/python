[["There are N children standing in a line. Each child is assigned a rating value.\nYou are giving candies to these children subjected to the following requirements:\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nWhat is the minimum candies you must give?", "class Solution {public:    int candy(vector<int> &ratings) {        int N=ratings.size();        vector<int> dp(N,1);                 for(int i=1;i<N;i++)        {            if(ratings[i]>ratings[i-1])                dp[i]=dp[i-1]+1;                                }                 int sum=dp[N-1];       for(int i=N-2;i>=0;i--)        {                        if(ratings[i]>ratings[i+1]&&dp[i]<=dp[i+1])                dp[i]=dp[i+1]+1;                     sum+=dp[i];        }        return sum;                      }};\n"], ["Given an array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?", "class Solution {public:    int singleNumber(int A[], int n) {        int sum=0;                 for(int i=0;i<n;i++)            sum^=A[i];        return sum;    }};\n"], ["A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\nReturn a deep copy of the list.", "class Solution {public:    RandomListNode *copyRandomList(RandomListNode *head) {        if(head==NULL)            return NULL;        RandomListNode *p=head;        while(p!=NULL)        {            RandomListNode *temp=new RandomListNode(p->label);            temp->next=p->next;            p->next=temp;            p=p->next->next;                    }        p=head;                 while(p!=NULL&&p->next!=NULL)        {            if(p->random!=NULL)                p->next->random=p->random->next;                            p=p->next->next;                    }                 RandomListNode *r=head->next;                 p=head;                while(p!=NULL&&p->next!=NULL)        {                           p->next=p->next->next;             p=p->next;        }                 return r;                               }};\n"], ["Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\nFor example, given\ns =\"leetcode\",\ndict =[\"leet\", \"code\"].\nReturn true because\"leetcode\"can be segmented as\"leet code\".", "class Solution {public:bool wordBreak(string s, unordered_set<string> &dict) {    int len = s.size();    vector<int>dp(len+1, 0);    dp[0]=1;    for(int i=0;i<dp.size();i++)    {         for(auto index=dict.begin();index!=dict.end();index++)        {           if(dp[i]==0)                continue;            int n=(*index).size();            if(i+n>len||n==0)                continue;            if(s.substr(i,n)==(*index))                    dp[i+n]=1;         }    }     return dp[len]; }};\n"], ["Given a linked list, determine if it has a cycle in it.\nFollow up:\nCan you solve it without using extra space?", "class Solution {public:    bool hasCycle(ListNode *head) {        if(head==NULL||head->next==NULL||head->next->next==NULL)            return false;                    ListNode *low=head->next,*fast=head->next->next;        while(low!=fast)        {            if(fast->next==NULL||fast->next->next==NULL)                return false;            fast=fast->next->next;            low=low->next;                    }        return true;                               }};\n"], ["Given a linked list, return the node where the cycle begins. If there is no cycle, returnnull.\nFollow up:\nCan you solve it without using extra space?", "class Solution {public:    ListNode *detectCycle(ListNode *head) {        if(head==NULL)            return NULL;        else if(head->next==NULL||head->next->next==NULL)            return NULL;        ListNode *low=head->next,*fast=head->next->next;        while(low!=fast&&fast->next!=NULL&&fast->next->next!=NULL)        {                        fast=fast->next->next;            low=low->next;                    }                      if(low!=fast)            return NULL;        else        {                         ListNode *temp=head;                        while(temp!=low)             {                low=low->next;                temp=temp->next;              }                                          return low;                                  }                      }};\n"], ["Given a singly linked list L: L 0→L 1→…→L n-1→L n,\nreorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→…\nYou must do this in-place without altering the nodes' values.\nFor example,\nGiven{1,2,3,4}, reorder it to{1,4,2,3}.", "class Solution {public:    void reorderList(ListNode *head) {        if(head==NULL||head->next==NULL||head->next->next==NULL)            return ;        ListNode *p=head;        ListNode *p1=head,*p2=head;        while(p2->next!=NULL&&p2->next->next!=NULL)        {            p2=p2->next->next;            p1=p1->next;                     }        p2=p1->next;        p1->next=NULL;                 //逆序        ListNode *q=NULL,*q1=p2,*q2;        while(q1!=NULL)        {                         q2=q1->next;            q1->next=q;            q=q1;            q1=q2;                    }                     p1=head;        ListNode *temp1,*temp2;        while(q!=NULL&&p1!=NULL)        {            temp1=p1->next;            p1->next=q;            temp2=q->next;            q->next=temp1;            p1=temp1;            q=temp2;                                  }                                                            }};\n"], ["Given a binary tree, return the preorder traversal of its nodes' values.\nFor example:\nGiven binary tree{1,#,2,3},\n   1\n    \\\n     2\n    /\n   3\n\nreturn[1,2,3].\nNote: Recursive solution is trivial, could you do it iteratively?", "class Solution {public:    vector<int> preorderTraversal(TreeNode *root) {        vector<int>result;        helper(root,result);        return result;    }};\n"], ["Given a binary tree, return the postorder traversal of its nodes' values.\nFor example:\nGiven binary tree{1,#,2,3},\n   1\n    \\\n     2\n    /\n   3\n\nreturn[3,2,1].\nNote: Recursive solution is trivial, could you do it iteratively?", "class Solution {public:    vector<int> postorderTraversal(TreeNode *root) {        vector<int> result;        if(root==NULL)            return result;        helper(root,result);        return result;             }};\n"], ["Sort a linked list in O(n log n) time using constant space complexity.", "class Solution {public: ListNode *merge(ListNode *head1,ListNode *head2) {     ListNode *p1=head1,*p2=head2;     ListNode temp(0);     ListNode *p=&temp;     while(p1&&p2)     {         if(p1->val>p2->val)          {             p->next=p2;            p2=p2->next;         }         else         {             p->next=p1;             p1=p1->next;          }         p=p->next;      }     if(p1) p->next=p1;     if(p2) p->next=p2;      return temp.next;   }  ListNode *sortList(ListNode *head) {     if(head==NULL||head->next==NULL)         return head;     ListNode *l=head,*f=head;     while(f->next!=NULL&&f->next->next!=NULL)     {         f=f->next->next;         l=l->next;     }      ListNode *right=sortList(l->next);     l->next=NULL;     ListNode *left=sortList(head);     return merge(left,right); }};\n"], ["Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are+,-,*,/. Each operand may be an integer or another expression.\nSome examples:\n  [\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\n  [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6", "class Solution {public:int evalRPN(vector<string> &tokens) {    int result;    stack<int> s;    for(int i=0;i<tokens.size();i++)    {        if(tokens[i]==\"+\")        {            int x=s.top();            s.pop();            int y=s.top();            s.pop();            result=x+y;            s.push(result);         }        else if(tokens[i]==\"-\")        {            int x=s.top();            s.pop();            int y=s.top();            s.pop();            result=y-x;            s.push(result);         }        else if(tokens[i]==\"*\")        {            int x=s.top();            s.pop();            int y=s.top();            s.pop();            result=x*y;            s.push(result);         }        else if(tokens[i]==\"/\")        {            int x=s.top();            s.pop();            int y=s.top();            s.pop();            result=y/x;            s.push(result);         }        else        {             s.push(atoi(tokens[i].c_str()));        }      }    return s.top();  } };\n"], ["Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.", "class Solution {         void helper(TreeNode *root,int cnt,int &min1)    {        if(root==NULL)            return ;        if(root->left==NULL&&root->right==NULL)       {            min1=min(min1,cnt);       }         helper(root->left,cnt+1,min1);        helper(root->right,cnt+1,min1);                     }          public:    int run(TreeNode *root) {        if(root==NULL)            return 0;        int min1=(1<<31)-1;        helper(root,1,min1);        return min1;             }};\n"], ["有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。", "\n"]]